<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <style>
    .card {
  font-family: arial;
  font-size: 20px;
  text-align: center;
  color: black;
  background-color: white;
}
.hidden {
  display:none;
}
    </style>
  </head>
  <body>
    <input id="user-word-type" type="text" placeholder="WordType" oninput="update()">
    <input id="user-front" type="text" placeholder="Front" value="plain" oninput="update()">
    <input id="user-back" type="text" placeholder="Back" value="polite past" oninput="update()">
    <input type="button" value="Show Answer" onclick="show()">
    <input type="button" value="Random" onclick="random()">
    <br><br><br>
    <div class="card">
    </div>
    <script>
      var frontTemplate = '<span id="word-type" class="hidden">{{WordType}}</span>\n<span class="required-conjugation hidden">{{Front}}</span>\n<span class="required-conjugation hidden">{{Back}}</span>\n\n{{Back}}  of <span id="replace-front">{{Front}}</span>\n\n<span id="error"></span>\n\n<script>\n// Generated by CoffeeScript 1.10.0\n(function() {\n  var Adjective, IAdjective, II, Kuru, NaAdjective, PoliteAdjective, PoliteAdjectiveNegative, PoliteNaAdjective, PoliteVerb, PoliteVerbNegative, RuVerb, Suru, UVerb, Verb, Word, aSounds, adjectives, eSounds, iSounds, oSounds, uSounds, verbs, w,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  aSounds = ["ら", "や", "ま", "は", "な", "た", "さ", "か", "あ", "ぱ", "ば", "だ", "ざ", "が"];\n\n  iSounds = ["り", "", "み", "ひ", "に", "ち", "し", "き", "い", "ぴ", "び", "ぢ", "じ", "ぎ"];\n\n  uSounds = ["る", "ゆ", "む", "ふ", "ぬ", "つ", "す", "く", "う", "ぷ", "ぶ", "づ", "ず", "ぐ"];\n\n  eSounds = ["れ", "", "め", "へ", "ね", "て", "せ", "け", "え", "ぺ", "べ", "で", "ぜ", "げ"];\n\n  oSounds = ["ろ", "よ", "も", "ほ", "の", "と", "そ", "こ", "お", "ぽ", "ぼ", "ど", "ぞ", "ご"];\n\n  String.prototype.replaceLast = function(from, to) {\n    var i, j, ref, s;\n    s = this.toString();\n    for (i = j = 0, ref = from.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      if (s.slice(-1) === from[i]) {\n        return s.slice(0, -1) + to[i];\n      }\n    }\n    return s;\n  };\n\n  Word = (function() {\n    function Word(_plain, _reading, _meaning) {\n      this._plain = _plain;\n      this._reading = _reading;\n      this._meaning = _meaning;\n    }\n\n    Word.prototype.plain = function() {\n      return this._plain;\n    };\n\n    Word.prototype.reading = function() {\n      return this._reading;\n    };\n\n    Word.prototype.meaning = function() {\n      return this._meaning;\n    };\n\n    Word.prototype.toString = function() {\n      return this.plain();\n    };\n\n    Word.prototype.conjugate = function(conj) {\n      return conj.split(\' \').reduce((function(w, c) {\n        return w[c]();\n      }), this);\n    };\n\n    return Word;\n\n  })();\n\n  Verb = (function(superClass) {\n    extend(Verb, superClass);\n\n    function Verb() {\n      return Verb.__super__.constructor.apply(this, arguments);\n    }\n\n    Verb.prototype.polite = function() {\n      return new PoliteVerb(this.stem());\n    };\n\n    Verb.prototype.te = function() {\n      return this.past().replace(/た$/, "て").replace(/だ$/, "で");\n    };\n\n    Verb.prototype.conditional = function() {\n      return this._plain.replaceLast(uSounds, eSounds) + "ば";\n    };\n\n    return Verb;\n\n  })(Word);\n\n  PoliteVerb = (function(superClass) {\n    extend(PoliteVerb, superClass);\n\n    function PoliteVerb(_plain) {\n      this._plain = _plain;\n    }\n\n    PoliteVerb.prototype.plain = function() {\n      return this._plain + "ます";\n    };\n\n    PoliteVerb.prototype.toString = function() {\n      return this.plain();\n    };\n\n    PoliteVerb.prototype.negative = function() {\n      return new PoliteVerbNegative(this._plain);\n    };\n\n    PoliteVerb.prototype.past = function() {\n      return this._plain + "ました";\n    };\n\n    PoliteVerb.prototype.volitional = function() {\n      return this._plain + "ましょう";\n    };\n\n    return PoliteVerb;\n\n  })(Word);\n\n  PoliteVerbNegative = (function(superClass) {\n    extend(PoliteVerbNegative, superClass);\n\n    function PoliteVerbNegative(_plain) {\n      this._plain = _plain;\n    }\n\n    PoliteVerbNegative.prototype.plain = function() {\n      return this._plain + "ません";\n    };\n\n    PoliteVerbNegative.prototype.toString = function() {\n      return this.plain();\n    };\n\n    PoliteVerbNegative.prototype.past = function() {\n      return this._plain + "ませんでした";\n    };\n\n    return PoliteVerbNegative;\n\n  })(PoliteVerb);\n\n  RuVerb = (function(superClass) {\n    extend(RuVerb, superClass);\n\n    function RuVerb() {\n      return RuVerb.__super__.constructor.apply(this, arguments);\n    }\n\n    RuVerb.prototype.type = function() {\n      return "ru-verb";\n    };\n\n    RuVerb.prototype.stem = function() {\n      return this._plain.replace(/る$/, "");\n    };\n\n    RuVerb.prototype.negative = function() {\n      return new IAdjective(this.stem() + "ない");\n    };\n\n    RuVerb.prototype.past = function() {\n      return this.stem() + "た";\n    };\n\n    RuVerb.prototype.potential = function() {\n      return new RuVerb(this.stem() + "られる");\n    };\n\n    RuVerb.prototype.volitional = function() {\n      return this.stem() + "よう";\n    };\n\n    return RuVerb;\n\n  })(Verb);\n\n  UVerb = (function(superClass) {\n    extend(UVerb, superClass);\n\n    function UVerb() {\n      return UVerb.__super__.constructor.apply(this, arguments);\n    }\n\n    UVerb.prototype.type = function() {\n      return "u-verb";\n    };\n\n    UVerb.prototype.stem = function() {\n      return this._plain.replaceLast(uSounds, iSounds);\n    };\n\n    UVerb.prototype.negative = function() {\n      var base;\n      base = (function() {\n        switch (this._plain) {\n          case "ある":\n            return "ない";\n          default:\n            return this._plain.replace(/う$/, "わ").replaceLast(uSounds, aSounds) + "ない";\n        }\n      }).call(this);\n      return new IAdjective(base);\n    };\n\n    UVerb.prototype.past = function() {\n      switch (this._plain) {\n        case "行く":\n          return "行った";\n        default:\n          return this._plain.replace(/う$/, "った").replace(/つ$/, "った").replace(/る$/, "った").replace(/む$/, "んだ").replace(/ぶ$/, "んだ").replace(/ぬ$/, "んだ").replace(/す$/, "した").replace(/く$/, "いた").replace(/ぐ$/, "いだ");\n      }\n    };\n\n    UVerb.prototype.potential = function() {\n      return new RuVerb(this._plain.replaceLast(uSounds, eSounds) + "る");\n    };\n\n    UVerb.prototype.volitional = function() {\n      return this._plain.replaceLast(uSounds, oSounds) + "う";\n    };\n\n    return UVerb;\n\n  })(Verb);\n\n  Suru = (function(superClass) {\n    extend(Suru, superClass);\n\n    function Suru() {\n      return Suru.__super__.constructor.apply(this, arguments);\n    }\n\n    Suru.prototype.type = function() {\n      return "suru-verb";\n    };\n\n    Suru.prototype.stem = function() {\n      return "し";\n    };\n\n    Suru.prototype.negative = function() {\n      return new IAdjective("しない");\n    };\n\n    Suru.prototype.past = function() {\n      return "した";\n    };\n\n    Suru.prototype.potential = function() {\n      return new RuVerb("できる");\n    };\n\n    Suru.prototype.volitional = function() {\n      return "しよう";\n    };\n\n    return Suru;\n\n  })(Verb);\n\n  Kuru = (function(superClass) {\n    extend(Kuru, superClass);\n\n    function Kuru() {\n      return Kuru.__super__.constructor.apply(this, arguments);\n    }\n\n    Kuru.prototype.type = function() {\n      return "kuru-verb";\n    };\n\n    Kuru.prototype.stem = function() {\n      return "き";\n    };\n\n    Kuru.prototype.negative = function() {\n      return new IAdjective("こない");\n    };\n\n    Kuru.prototype.past = function() {\n      return "きた";\n    };\n\n    Kuru.prototype.potential = function() {\n      return new RuVerb("こられる");\n    };\n\n    Kuru.prototype.volitional = function() {\n      return "こよう";\n    };\n\n    return Kuru;\n\n  })(Verb);\n\n  Adjective = (function(superClass) {\n    extend(Adjective, superClass);\n\n    function Adjective() {\n      return Adjective.__super__.constructor.apply(this, arguments);\n    }\n\n    Adjective.prototype.polite = function() {\n      return new PoliteAdjective(this);\n    };\n\n    Adjective.prototype.toString = function() {\n      return this.plain();\n    };\n\n    return Adjective;\n\n  })(Word);\n\n  PoliteAdjective = (function(superClass) {\n    extend(PoliteAdjective, superClass);\n\n    function PoliteAdjective(_plain) {\n      this._plain = _plain;\n    }\n\n    PoliteAdjective.prototype.plain = function() {\n      return this._plain + "です";\n    };\n\n    PoliteAdjective.prototype.toString = function() {\n      return this.plain();\n    };\n\n    PoliteAdjective.prototype.negative = function() {\n      return new PoliteAdjectiveNegative(this._plain.negative());\n    };\n\n    PoliteAdjective.prototype.past = function() {\n      return this._plain.past() + "です";\n    };\n\n    return PoliteAdjective;\n\n  })(Adjective);\n\n  PoliteAdjectiveNegative = (function(superClass) {\n    extend(PoliteAdjectiveNegative, superClass);\n\n    function PoliteAdjectiveNegative(_plain) {\n      this._plain = _plain;\n    }\n\n    PoliteAdjectiveNegative.prototype.plain = function() {\n      return this._plain + "です";\n    };\n\n    PoliteAdjectiveNegative.prototype.past = function() {\n      return this._plain.past() + "です";\n    };\n\n    return PoliteAdjectiveNegative;\n\n  })(PoliteAdjective);\n\n  PoliteNaAdjective = (function(superClass) {\n    extend(PoliteNaAdjective, superClass);\n\n    function PoliteNaAdjective() {\n      return PoliteNaAdjective.__super__.constructor.apply(this, arguments);\n    }\n\n    PoliteNaAdjective.prototype.past = function() {\n      return this._plain + "でした";\n    };\n\n    return PoliteNaAdjective;\n\n  })(PoliteAdjective);\n\n  IAdjective = (function(superClass) {\n    extend(IAdjective, superClass);\n\n    function IAdjective() {\n      return IAdjective.__super__.constructor.apply(this, arguments);\n    }\n\n    IAdjective.prototype.type = function() {\n      return "i-adjective";\n    };\n\n    IAdjective.prototype.adverb = function() {\n      return this._plain.replace(/い$/, "く");\n    };\n\n    IAdjective.prototype.negative = function() {\n      return new IAdjective(this._plain.replace(/い$/, "くない"));\n    };\n\n    IAdjective.prototype.past = function() {\n      return this._plain.replace(/い$/, "かった");\n    };\n\n    IAdjective.prototype.te = function() {\n      return this._plain.replace(/い$/, "くて");\n    };\n\n    IAdjective.prototype.conditional = function() {\n      return this._plain.replace(/い$/, "ければ");\n    };\n\n    return IAdjective;\n\n  })(Adjective);\n\n  II = (function(superClass) {\n    extend(II, superClass);\n\n    function II() {\n      return II.__super__.constructor.apply(this, arguments);\n    }\n\n    II.prototype.plain = function() {\n      return "いい";\n    };\n\n    return II;\n\n  })(IAdjective);\n\n  NaAdjective = (function(superClass) {\n    extend(NaAdjective, superClass);\n\n    function NaAdjective() {\n      return NaAdjective.__super__.constructor.apply(this, arguments);\n    }\n\n    NaAdjective.prototype.type = function() {\n      return "na-adjective";\n    };\n\n    NaAdjective.prototype.adverb = function() {\n      return this._plain + "に";\n    };\n\n    NaAdjective.prototype.negative = function() {\n      return new IAdjective(this._plain + "じゃない");\n    };\n\n    NaAdjective.prototype.past = function() {\n      return this._plain + "だった";\n    };\n\n    NaAdjective.prototype.te = function() {\n      return this._plain + "で";\n    };\n\n    NaAdjective.prototype.conditional = function() {\n      return this._plain + "であれば";\n    };\n\n    return NaAdjective;\n\n  })(Adjective);\n\n  verbs = [\n    {\n      plain: "見る",\n      reading: "みる",\n      meaning: "to see"\n    }, {\n      plain: "食べる",\n      reading: "たべる",\n      meaning: "to eat"\n    }, {\n      plain: "寝る",\n      reading: "ねる",\n      meaning: "to sleep"\n    }, {\n      plain: "起きる",\n      reading: "おきる",\n      meaning: "to wake up"\n    }, {\n      plain: "考える",\n      reading: "かんがえる",\n      meaning: "to think"\n    }, {\n      plain: "教える",\n      reading: "おしえる",\n      meaning: "to teach"\n    }, {\n      plain: "出る",\n      reading: "でる",\n      meaning: "to exit"\n    }, {\n      plain: "着る",\n      reading: "きる",\n      meaning: "to wear"\n    }, {\n      plain: "居る",\n      reading: "いる",\n      meaning: "to be (animate)"\n    }, {\n      plain: "在る",\n      reading: "ある",\n      meaning: "to be (inanimate)"\n    }, {\n      plain: "話す",\n      reading: "はなす",\n      meaning: "to talk"\n    }, {\n      plain: "聞く",\n      reading: "きく",\n      meaning: "to hear"\n    }, {\n      plain: "泳ぐ",\n      reading: "およぐ",\n      meaning: "to swim"\n    }, {\n      plain: "遊ぶ",\n      reading: "あそぶ",\n      meaning: "to play"\n    }, {\n      plain: "待つ",\n      reading: "まつ",\n      meaning: "to wait"\n    }, {\n      plain: "飲む",\n      reading: "のむ",\n      meaning: "to drink"\n    }, {\n      plain: "買う",\n      reading: "かう",\n      meaning: "to buy"\n    }, {\n      plain: "帰る",\n      reading: "かえる",\n      meaning: "to return"\n    }, {\n      plain: "死ぬ",\n      reading: "しぬ",\n      meaning: "to die"\n    }, {\n      plain: "為る",\n      reading: "する",\n      meaning: "to do"\n    }, {\n      plain: "来る",\n      reading: "くる",\n      meaning: "to come"\n    }\n  ];\n\n  adjectives = [\n    {\n      plain: "良い",\n      reading: "いい",\n      meaning: "good"\n    }, {\n      plain: "奇麗",\n      reading: "きれい",\n      meaning: "pretty"\n    }, {\n      plain: "静か",\n      reading: "しずか",\n      meaning: "quiet"\n    }, {\n      plain: "親切",\n      reading: "しんせつ",\n      meaning: "kind"\n    }, {\n      plain: "好き",\n      reading: "すき",\n      meaning: "like"\n    }, {\n      plain: "嫌い",\n      reading: "きらい",\n      meaning: "hate"\n    }, {\n      plain: "美味しい",\n      reading: "おいしい",\n      meaning: "tasty"\n    }, {\n      plain: "高い",\n      reading: "たかい",\n      meaning: "tall"\n    }\n  ];\n\n  window.classify = function(plain, reading, meaning) {\n    var ref;\n    switch (reading) {\n      case "する":\n        return new Suru(plain, reading, meaning);\n      case "くる":\n        return new Kuru(plain, reading, meaning);\n      case "いい":\n        return new II(plain, reading, meaning);\n      default:\n        switch (plain.slice(-1)) {\n          case "う":\n          case "つ":\n          case "む":\n          case "ぶ":\n          case "ぬ":\n          case "す":\n          case "く":\n          case "ぐ":\n            return new UVerb(plain, reading, meaning);\n          case "る":\n            switch (plain) {\n              case "要る":\n              case "帰る":\n              case "切る":\n              case "喋る":\n              case "知る":\n              case "入る":\n              case "走る":\n              case "減る":\n              case "焦る":\n              case "限る":\n              case "蹴る":\n              case "滑る":\n              case "握る":\n              case "練る":\n              case "参る":\n              case "交じる":\n              case "混じる":\n              case "嘲る":\n              case "覆る":\n              case "遮る":\n              case "罵る":\n              case "捻る":\n              case "翻る":\n              case "滅入る":\n              case "蘇る":\n                return new UVerb(plain, reading, meaning);\n              default:\n                if (ref = reading.slice(-2, -1), indexOf.call(eSounds.concat(iSounds), ref) >= 0) {\n                  return new RuVerb(plain, reading, meaning);\n                } else {\n                  return new UVerb(plain, reading, meaning);\n                }\n            }\n            break;\n          case "い":\n            switch (plain) {\n              case "嫌い":\n              case "奇麗":\n              case "綺麗":\n              case "きれい":\n                return new NaAdjective(plain, reading, meaning);\n              default:\n                return new IAdjective(plain, reading, meaning);\n            }\n            break;\n          default:\n            return new NaAdjective(plain, reading, meaning);\n        }\n    }\n  };\n\n  window.words = (function() {\n    var j, len, ref, results;\n    ref = verbs.concat(adjectives);\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      w = ref[j];\n      results.push(classify(w.plain, w.reading, w.meaning));\n    }\n    return results;\n  })();\n\n  window.getByPlain = function(plain) {\n    var j, len, ref;\n    ref = window.words;\n    for (j = 0, len = ref.length; j < len; j++) {\n      w = ref[j];\n      if (w.plain() === plain) {\n        return w;\n      }\n    }\n  };\n\n}).call(this);\n\n\n\n// Generated by CoffeeScript 1.10.0\n(function() {\n  var makeKey;\n\n  makeKey = function(name) {\n    return \'mononofu_\' + name;\n  };\n\n  window.globalSet = function(name, value) {\n    if (typeof py !== "undefined") {\n      return py[makeKey(name)] = value.toString();\n    } else if (typeof sessionStorage !== "undefined") {\n      return sessionStorage.setItem(makeKey(name), value.toString());\n    } else {\n      return window[makeKey(name)] = value.toString();\n    }\n  };\n\n  window.globalGet = function(name) {\n    if (typeof py !== "undefined") {\n      return py[makeKey(name)];\n    } else if (typeof sessionStorage !== "undefined") {\n      return sessionStorage.getItem(makeKey(name));\n    } else {\n      return window[makeKey(name)];\n    }\n  };\n\n}).call(this);\n\n\n\n// Generated by CoffeeScript 1.10.0\n(function() {\n  var candidates, elem, error, error1, k, l, len, len1, ref, ref1, shuffle, type, w, word;\n\n  shuffle = function(xs) {\n    var i, j, k, ref, ref1;\n    for (i = k = ref = xs.length - 1; ref <= 0 ? k < 0 : k > 0; i = ref <= 0 ? ++k : --k) {\n      j = Math.floor(Math.random() * xs.length);\n      ref1 = [xs[j], xs[i]], xs[i] = ref1[0], xs[j] = ref1[1];\n    }\n    return xs;\n  };\n\n  if (document.getElementById(\'answer\') === null) {\n    candidates = window.words;\n    type = document.getElementById(\'word-type\');\n    if (type !== null && type.innerHTML !== \'\') {\n      candidates = (function() {\n        var k, len, results;\n        results = [];\n        for (k = 0, len = candidates.length; k < len; k++) {\n          w = candidates[k];\n          if (w.type().indexOf(type.innerHTML) === 0) {\n            results.push(w);\n          }\n        }\n        return results;\n      })();\n    }\n    ref = shuffle(candidates);\n    for (k = 0, len = ref.length; k < len; k++) {\n      word = ref[k];\n      try {\n        ref1 = document.getElementsByClassName(\'required-conjugation\');\n        for (l = 0, len1 = ref1.length; l < len1; l++) {\n          elem = ref1[l];\n          word.conjugate(elem.innerHTML);\n        }\n        globalSet(\'word\', word);\n        break;\n      } catch (error1) {\n        error = error1;\n        document.getElementById(\'error\').innerHTML = error;\n      }\n    }\n  }\n\n  elem = document.getElementById(\'replace-front\');\n\n  elem.innerHTML = getByPlain(globalGet(\'word\')).conjugate(elem.innerHTML);\n\n  document.getElementById(\'error\').innerHTML = \'\';\n\n}).call(this);\n\n</scr'+'ipt>';
      var backTemplate = '{{Back}}  of <span class="replace">{{Front}}</span>\n\n<hr id="answer">\n\n<span class="replace">{{Back}}</span>\n<br><br>\nfrom <span class="replace">plain</span> (<span class="replace">reading</span>),\n  <i><span class="replace">meaning</span></i>\n  <span style="color:grey">[<span class="replace">type</span>]</span>\n\n<script>\n// Generated by CoffeeScript 1.10.0\n(function() {\n  var Adjective, IAdjective, II, Kuru, NaAdjective, PoliteAdjective, PoliteAdjectiveNegative, PoliteNaAdjective, PoliteVerb, PoliteVerbNegative, RuVerb, Suru, UVerb, Verb, Word, aSounds, adjectives, eSounds, iSounds, oSounds, uSounds, verbs, w,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  aSounds = ["ら", "や", "ま", "は", "な", "た", "さ", "か", "あ", "ぱ", "ば", "だ", "ざ", "が"];\n\n  iSounds = ["り", "", "み", "ひ", "に", "ち", "し", "き", "い", "ぴ", "び", "ぢ", "じ", "ぎ"];\n\n  uSounds = ["る", "ゆ", "む", "ふ", "ぬ", "つ", "す", "く", "う", "ぷ", "ぶ", "づ", "ず", "ぐ"];\n\n  eSounds = ["れ", "", "め", "へ", "ね", "て", "せ", "け", "え", "ぺ", "べ", "で", "ぜ", "げ"];\n\n  oSounds = ["ろ", "よ", "も", "ほ", "の", "と", "そ", "こ", "お", "ぽ", "ぼ", "ど", "ぞ", "ご"];\n\n  String.prototype.replaceLast = function(from, to) {\n    var i, j, ref, s;\n    s = this.toString();\n    for (i = j = 0, ref = from.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      if (s.slice(-1) === from[i]) {\n        return s.slice(0, -1) + to[i];\n      }\n    }\n    return s;\n  };\n\n  Word = (function() {\n    function Word(_plain, _reading, _meaning) {\n      this._plain = _plain;\n      this._reading = _reading;\n      this._meaning = _meaning;\n    }\n\n    Word.prototype.plain = function() {\n      return this._plain;\n    };\n\n    Word.prototype.reading = function() {\n      return this._reading;\n    };\n\n    Word.prototype.meaning = function() {\n      return this._meaning;\n    };\n\n    Word.prototype.toString = function() {\n      return this.plain();\n    };\n\n    Word.prototype.conjugate = function(conj) {\n      return conj.split(\' \').reduce((function(w, c) {\n        return w[c]();\n      }), this);\n    };\n\n    return Word;\n\n  })();\n\n  Verb = (function(superClass) {\n    extend(Verb, superClass);\n\n    function Verb() {\n      return Verb.__super__.constructor.apply(this, arguments);\n    }\n\n    Verb.prototype.polite = function() {\n      return new PoliteVerb(this.stem());\n    };\n\n    Verb.prototype.te = function() {\n      return this.past().replace(/た$/, "て").replace(/だ$/, "で");\n    };\n\n    Verb.prototype.conditional = function() {\n      return this._plain.replaceLast(uSounds, eSounds) + "ば";\n    };\n\n    return Verb;\n\n  })(Word);\n\n  PoliteVerb = (function(superClass) {\n    extend(PoliteVerb, superClass);\n\n    function PoliteVerb(_plain) {\n      this._plain = _plain;\n    }\n\n    PoliteVerb.prototype.plain = function() {\n      return this._plain + "ます";\n    };\n\n    PoliteVerb.prototype.toString = function() {\n      return this.plain();\n    };\n\n    PoliteVerb.prototype.negative = function() {\n      return new PoliteVerbNegative(this._plain);\n    };\n\n    PoliteVerb.prototype.past = function() {\n      return this._plain + "ました";\n    };\n\n    PoliteVerb.prototype.volitional = function() {\n      return this._plain + "ましょう";\n    };\n\n    return PoliteVerb;\n\n  })(Word);\n\n  PoliteVerbNegative = (function(superClass) {\n    extend(PoliteVerbNegative, superClass);\n\n    function PoliteVerbNegative(_plain) {\n      this._plain = _plain;\n    }\n\n    PoliteVerbNegative.prototype.plain = function() {\n      return this._plain + "ません";\n    };\n\n    PoliteVerbNegative.prototype.toString = function() {\n      return this.plain();\n    };\n\n    PoliteVerbNegative.prototype.past = function() {\n      return this._plain + "ませんでした";\n    };\n\n    return PoliteVerbNegative;\n\n  })(PoliteVerb);\n\n  RuVerb = (function(superClass) {\n    extend(RuVerb, superClass);\n\n    function RuVerb() {\n      return RuVerb.__super__.constructor.apply(this, arguments);\n    }\n\n    RuVerb.prototype.type = function() {\n      return "ru-verb";\n    };\n\n    RuVerb.prototype.stem = function() {\n      return this._plain.replace(/る$/, "");\n    };\n\n    RuVerb.prototype.negative = function() {\n      return new IAdjective(this.stem() + "ない");\n    };\n\n    RuVerb.prototype.past = function() {\n      return this.stem() + "た";\n    };\n\n    RuVerb.prototype.potential = function() {\n      return new RuVerb(this.stem() + "られる");\n    };\n\n    RuVerb.prototype.volitional = function() {\n      return this.stem() + "よう";\n    };\n\n    return RuVerb;\n\n  })(Verb);\n\n  UVerb = (function(superClass) {\n    extend(UVerb, superClass);\n\n    function UVerb() {\n      return UVerb.__super__.constructor.apply(this, arguments);\n    }\n\n    UVerb.prototype.type = function() {\n      return "u-verb";\n    };\n\n    UVerb.prototype.stem = function() {\n      return this._plain.replaceLast(uSounds, iSounds);\n    };\n\n    UVerb.prototype.negative = function() {\n      var base;\n      base = (function() {\n        switch (this._plain) {\n          case "ある":\n            return "ない";\n          default:\n            return this._plain.replace(/う$/, "わ").replaceLast(uSounds, aSounds) + "ない";\n        }\n      }).call(this);\n      return new IAdjective(base);\n    };\n\n    UVerb.prototype.past = function() {\n      switch (this._plain) {\n        case "行く":\n          return "行った";\n        default:\n          return this._plain.replace(/う$/, "った").replace(/つ$/, "った").replace(/る$/, "った").replace(/む$/, "んだ").replace(/ぶ$/, "んだ").replace(/ぬ$/, "んだ").replace(/す$/, "した").replace(/く$/, "いた").replace(/ぐ$/, "いだ");\n      }\n    };\n\n    UVerb.prototype.potential = function() {\n      return new RuVerb(this._plain.replaceLast(uSounds, eSounds) + "る");\n    };\n\n    UVerb.prototype.volitional = function() {\n      return this._plain.replaceLast(uSounds, oSounds) + "う";\n    };\n\n    return UVerb;\n\n  })(Verb);\n\n  Suru = (function(superClass) {\n    extend(Suru, superClass);\n\n    function Suru() {\n      return Suru.__super__.constructor.apply(this, arguments);\n    }\n\n    Suru.prototype.type = function() {\n      return "suru-verb";\n    };\n\n    Suru.prototype.stem = function() {\n      return "し";\n    };\n\n    Suru.prototype.negative = function() {\n      return new IAdjective("しない");\n    };\n\n    Suru.prototype.past = function() {\n      return "した";\n    };\n\n    Suru.prototype.potential = function() {\n      return new RuVerb("できる");\n    };\n\n    Suru.prototype.volitional = function() {\n      return "しよう";\n    };\n\n    return Suru;\n\n  })(Verb);\n\n  Kuru = (function(superClass) {\n    extend(Kuru, superClass);\n\n    function Kuru() {\n      return Kuru.__super__.constructor.apply(this, arguments);\n    }\n\n    Kuru.prototype.type = function() {\n      return "kuru-verb";\n    };\n\n    Kuru.prototype.stem = function() {\n      return "き";\n    };\n\n    Kuru.prototype.negative = function() {\n      return new IAdjective("こない");\n    };\n\n    Kuru.prototype.past = function() {\n      return "きた";\n    };\n\n    Kuru.prototype.potential = function() {\n      return new RuVerb("こられる");\n    };\n\n    Kuru.prototype.volitional = function() {\n      return "こよう";\n    };\n\n    return Kuru;\n\n  })(Verb);\n\n  Adjective = (function(superClass) {\n    extend(Adjective, superClass);\n\n    function Adjective() {\n      return Adjective.__super__.constructor.apply(this, arguments);\n    }\n\n    Adjective.prototype.polite = function() {\n      return new PoliteAdjective(this);\n    };\n\n    Adjective.prototype.toString = function() {\n      return this.plain();\n    };\n\n    return Adjective;\n\n  })(Word);\n\n  PoliteAdjective = (function(superClass) {\n    extend(PoliteAdjective, superClass);\n\n    function PoliteAdjective(_plain) {\n      this._plain = _plain;\n    }\n\n    PoliteAdjective.prototype.plain = function() {\n      return this._plain + "です";\n    };\n\n    PoliteAdjective.prototype.toString = function() {\n      return this.plain();\n    };\n\n    PoliteAdjective.prototype.negative = function() {\n      return new PoliteAdjectiveNegative(this._plain.negative());\n    };\n\n    PoliteAdjective.prototype.past = function() {\n      return this._plain.past() + "です";\n    };\n\n    return PoliteAdjective;\n\n  })(Adjective);\n\n  PoliteAdjectiveNegative = (function(superClass) {\n    extend(PoliteAdjectiveNegative, superClass);\n\n    function PoliteAdjectiveNegative(_plain) {\n      this._plain = _plain;\n    }\n\n    PoliteAdjectiveNegative.prototype.plain = function() {\n      return this._plain + "です";\n    };\n\n    PoliteAdjectiveNegative.prototype.past = function() {\n      return this._plain.past() + "です";\n    };\n\n    return PoliteAdjectiveNegative;\n\n  })(PoliteAdjective);\n\n  PoliteNaAdjective = (function(superClass) {\n    extend(PoliteNaAdjective, superClass);\n\n    function PoliteNaAdjective() {\n      return PoliteNaAdjective.__super__.constructor.apply(this, arguments);\n    }\n\n    PoliteNaAdjective.prototype.past = function() {\n      return this._plain + "でした";\n    };\n\n    return PoliteNaAdjective;\n\n  })(PoliteAdjective);\n\n  IAdjective = (function(superClass) {\n    extend(IAdjective, superClass);\n\n    function IAdjective() {\n      return IAdjective.__super__.constructor.apply(this, arguments);\n    }\n\n    IAdjective.prototype.type = function() {\n      return "i-adjective";\n    };\n\n    IAdjective.prototype.adverb = function() {\n      return this._plain.replace(/い$/, "く");\n    };\n\n    IAdjective.prototype.negative = function() {\n      return new IAdjective(this._plain.replace(/い$/, "くない"));\n    };\n\n    IAdjective.prototype.past = function() {\n      return this._plain.replace(/い$/, "かった");\n    };\n\n    IAdjective.prototype.te = function() {\n      return this._plain.replace(/い$/, "くて");\n    };\n\n    IAdjective.prototype.conditional = function() {\n      return this._plain.replace(/い$/, "ければ");\n    };\n\n    return IAdjective;\n\n  })(Adjective);\n\n  II = (function(superClass) {\n    extend(II, superClass);\n\n    function II() {\n      return II.__super__.constructor.apply(this, arguments);\n    }\n\n    II.prototype.plain = function() {\n      return "いい";\n    };\n\n    return II;\n\n  })(IAdjective);\n\n  NaAdjective = (function(superClass) {\n    extend(NaAdjective, superClass);\n\n    function NaAdjective() {\n      return NaAdjective.__super__.constructor.apply(this, arguments);\n    }\n\n    NaAdjective.prototype.type = function() {\n      return "na-adjective";\n    };\n\n    NaAdjective.prototype.adverb = function() {\n      return this._plain + "に";\n    };\n\n    NaAdjective.prototype.negative = function() {\n      return new IAdjective(this._plain + "じゃない");\n    };\n\n    NaAdjective.prototype.past = function() {\n      return this._plain + "だった";\n    };\n\n    NaAdjective.prototype.te = function() {\n      return this._plain + "で";\n    };\n\n    NaAdjective.prototype.conditional = function() {\n      return this._plain + "であれば";\n    };\n\n    return NaAdjective;\n\n  })(Adjective);\n\n  verbs = [\n    {\n      plain: "見る",\n      reading: "みる",\n      meaning: "to see"\n    }, {\n      plain: "食べる",\n      reading: "たべる",\n      meaning: "to eat"\n    }, {\n      plain: "寝る",\n      reading: "ねる",\n      meaning: "to sleep"\n    }, {\n      plain: "起きる",\n      reading: "おきる",\n      meaning: "to wake up"\n    }, {\n      plain: "考える",\n      reading: "かんがえる",\n      meaning: "to think"\n    }, {\n      plain: "教える",\n      reading: "おしえる",\n      meaning: "to teach"\n    }, {\n      plain: "出る",\n      reading: "でる",\n      meaning: "to exit"\n    }, {\n      plain: "着る",\n      reading: "きる",\n      meaning: "to wear"\n    }, {\n      plain: "居る",\n      reading: "いる",\n      meaning: "to be (animate)"\n    }, {\n      plain: "在る",\n      reading: "ある",\n      meaning: "to be (inanimate)"\n    }, {\n      plain: "話す",\n      reading: "はなす",\n      meaning: "to talk"\n    }, {\n      plain: "聞く",\n      reading: "きく",\n      meaning: "to hear"\n    }, {\n      plain: "泳ぐ",\n      reading: "およぐ",\n      meaning: "to swim"\n    }, {\n      plain: "遊ぶ",\n      reading: "あそぶ",\n      meaning: "to play"\n    }, {\n      plain: "待つ",\n      reading: "まつ",\n      meaning: "to wait"\n    }, {\n      plain: "飲む",\n      reading: "のむ",\n      meaning: "to drink"\n    }, {\n      plain: "買う",\n      reading: "かう",\n      meaning: "to buy"\n    }, {\n      plain: "帰る",\n      reading: "かえる",\n      meaning: "to return"\n    }, {\n      plain: "死ぬ",\n      reading: "しぬ",\n      meaning: "to die"\n    }, {\n      plain: "為る",\n      reading: "する",\n      meaning: "to do"\n    }, {\n      plain: "来る",\n      reading: "くる",\n      meaning: "to come"\n    }\n  ];\n\n  adjectives = [\n    {\n      plain: "良い",\n      reading: "いい",\n      meaning: "good"\n    }, {\n      plain: "奇麗",\n      reading: "きれい",\n      meaning: "pretty"\n    }, {\n      plain: "静か",\n      reading: "しずか",\n      meaning: "quiet"\n    }, {\n      plain: "親切",\n      reading: "しんせつ",\n      meaning: "kind"\n    }, {\n      plain: "好き",\n      reading: "すき",\n      meaning: "like"\n    }, {\n      plain: "嫌い",\n      reading: "きらい",\n      meaning: "hate"\n    }, {\n      plain: "美味しい",\n      reading: "おいしい",\n      meaning: "tasty"\n    }, {\n      plain: "高い",\n      reading: "たかい",\n      meaning: "tall"\n    }\n  ];\n\n  window.classify = function(plain, reading, meaning) {\n    var ref;\n    switch (reading) {\n      case "する":\n        return new Suru(plain, reading, meaning);\n      case "くる":\n        return new Kuru(plain, reading, meaning);\n      case "いい":\n        return new II(plain, reading, meaning);\n      default:\n        switch (plain.slice(-1)) {\n          case "う":\n          case "つ":\n          case "む":\n          case "ぶ":\n          case "ぬ":\n          case "す":\n          case "く":\n          case "ぐ":\n            return new UVerb(plain, reading, meaning);\n          case "る":\n            switch (plain) {\n              case "要る":\n              case "帰る":\n              case "切る":\n              case "喋る":\n              case "知る":\n              case "入る":\n              case "走る":\n              case "減る":\n              case "焦る":\n              case "限る":\n              case "蹴る":\n              case "滑る":\n              case "握る":\n              case "練る":\n              case "参る":\n              case "交じる":\n              case "混じる":\n              case "嘲る":\n              case "覆る":\n              case "遮る":\n              case "罵る":\n              case "捻る":\n              case "翻る":\n              case "滅入る":\n              case "蘇る":\n                return new UVerb(plain, reading, meaning);\n              default:\n                if (ref = reading.slice(-2, -1), indexOf.call(eSounds.concat(iSounds), ref) >= 0) {\n                  return new RuVerb(plain, reading, meaning);\n                } else {\n                  return new UVerb(plain, reading, meaning);\n                }\n            }\n            break;\n          case "い":\n            switch (plain) {\n              case "嫌い":\n              case "奇麗":\n              case "綺麗":\n              case "きれい":\n                return new NaAdjective(plain, reading, meaning);\n              default:\n                return new IAdjective(plain, reading, meaning);\n            }\n            break;\n          default:\n            return new NaAdjective(plain, reading, meaning);\n        }\n    }\n  };\n\n  window.words = (function() {\n    var j, len, ref, results;\n    ref = verbs.concat(adjectives);\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      w = ref[j];\n      results.push(classify(w.plain, w.reading, w.meaning));\n    }\n    return results;\n  })();\n\n  window.getByPlain = function(plain) {\n    var j, len, ref;\n    ref = window.words;\n    for (j = 0, len = ref.length; j < len; j++) {\n      w = ref[j];\n      if (w.plain() === plain) {\n        return w;\n      }\n    }\n  };\n\n}).call(this);\n\n\n\n// Generated by CoffeeScript 1.10.0\n(function() {\n  var makeKey;\n\n  makeKey = function(name) {\n    return \'mononofu_\' + name;\n  };\n\n  window.globalSet = function(name, value) {\n    if (typeof py !== "undefined") {\n      return py[makeKey(name)] = value.toString();\n    } else if (typeof sessionStorage !== "undefined") {\n      return sessionStorage.setItem(makeKey(name), value.toString());\n    } else {\n      return window[makeKey(name)] = value.toString();\n    }\n  };\n\n  window.globalGet = function(name) {\n    if (typeof py !== "undefined") {\n      return py[makeKey(name)];\n    } else if (typeof sessionStorage !== "undefined") {\n      return sessionStorage.getItem(makeKey(name));\n    } else {\n      return window[makeKey(name)];\n    }\n  };\n\n}).call(this);\n\n\n\n// Generated by CoffeeScript 1.10.0\n(function() {\n  var elem, error, error1, i, len, ref, want;\n\n  ref = document.getElementsByClassName(\'replace\');\n  for (i = 0, len = ref.length; i < len; i++) {\n    elem = ref[i];\n    try {\n      want = elem.innerHTML;\n      elem.innerHTML = getByPlain(globalGet(\'word\')).conjugate(want);\n    } catch (error1) {\n      error = error1;\n      elem.innerHTML = "";\n    }\n  }\n\n}).call(this);\n\n</scr'+'ipt>';
      var card = document.getElementsByClassName('card')[0];

      function fillPlaceholders(template) {
        return template
            .replace(new RegExp('{{WordType}}', 'g'), document.getElementById('user-word-type').value)
            .replace(new RegExp('{{Front}}', 'g'), document.getElementById('user-front').value)
            .replace(new RegExp('{{Back}}', 'g'), document.getElementById('user-back').value);
      }

      function runScripts(tag) {
        var scripts = tag.getElementsByTagName('script');
        for(var i = 0; i < scripts.length; i++) {
          eval(scripts[i].innerHTML);
        }
      }

      function update() {
        card.innerHTML = fillPlaceholders(frontTemplate);
        runScripts(card);
      }

      function show() {
        card.innerHTML = fillPlaceholders(backTemplate)
            .replace('{{FrontSide}}', fillPlaceholders(frontTemplate));
        runScripts(card);
      }

      function random() {
        window.wo
        rd = undefined;
        update();
      }

      update();
    </script>
  </body>
</html>