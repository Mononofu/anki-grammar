<span id="word-type" class="hidden">{{WordType}}</span>
<span class="required-conjugation hidden">{{Front}}</span>
<span class="required-conjugation hidden">{{Back}}</span>

{{Back}}  of <span id="replace-front">{{Front}}</span>

<span id="error"></span>

<script>
// Generated by CoffeeScript 1.10.0
(function() {
  var Adjective, IAdjective, II, Kuru, NaAdjective, PoliteAdjective, PoliteAdjectiveNegative, PoliteNaAdjective, PoliteVerb, PoliteVerbNegative, RuVerb, Suru, UVerb, Verb, Word, aSounds, adjectives, eSounds, iSounds, oSounds, uSounds, verbs, w,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  aSounds = ["ら", "や", "ま", "は", "な", "た", "さ", "か", "あ", "ぱ", "ば", "だ", "ざ", "が"];

  iSounds = ["り", "", "み", "ひ", "に", "ち", "し", "き", "い", "ぴ", "び", "ぢ", "じ", "ぎ"];

  uSounds = ["る", "ゆ", "む", "ふ", "ぬ", "つ", "す", "く", "う", "ぷ", "ぶ", "づ", "ず", "ぐ"];

  eSounds = ["れ", "", "め", "へ", "ね", "て", "せ", "け", "え", "ぺ", "べ", "で", "ぜ", "げ"];

  oSounds = ["ろ", "よ", "も", "ほ", "の", "と", "そ", "こ", "お", "ぽ", "ぼ", "ど", "ぞ", "ご"];

  String.prototype.replaceLast = function(from, to) {
    var i, j, ref, s;
    s = this.toString();
    for (i = j = 0, ref = from.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (s.slice(-1) === from[i]) {
        return s.slice(0, -1) + to[i];
      }
    }
    return s;
  };

  Word = (function() {
    function Word(_plain, _reading, _meaning) {
      this._plain = _plain;
      this._reading = _reading;
      this._meaning = _meaning;
    }

    Word.prototype.plain = function() {
      return this._plain;
    };

    Word.prototype.reading = function() {
      return this._reading;
    };

    Word.prototype.meaning = function() {
      return this._meaning;
    };

    Word.prototype.toString = function() {
      return this.plain();
    };

    Word.prototype.conjugate = function(conj) {
      return conj.split(' ').reduce((function(w, c) {
        return w[c]();
      }), this);
    };

    return Word;

  })();

  Verb = (function(superClass) {
    extend(Verb, superClass);

    function Verb() {
      return Verb.__super__.constructor.apply(this, arguments);
    }

    Verb.prototype.polite = function() {
      return new PoliteVerb(this.stem());
    };

    Verb.prototype.te = function() {
      return this.past().replace(/た$/, "て").replace(/だ$/, "で");
    };

    Verb.prototype.conditional = function() {
      return this._plain.replaceLast(uSounds, eSounds) + "ば";
    };

    return Verb;

  })(Word);

  PoliteVerb = (function(superClass) {
    extend(PoliteVerb, superClass);

    function PoliteVerb(_plain) {
      this._plain = _plain;
    }

    PoliteVerb.prototype.plain = function() {
      return this._plain + "ます";
    };

    PoliteVerb.prototype.toString = function() {
      return this.plain();
    };

    PoliteVerb.prototype.negative = function() {
      return new PoliteVerbNegative(this._plain);
    };

    PoliteVerb.prototype.past = function() {
      return this._plain + "ました";
    };

    PoliteVerb.prototype.volitional = function() {
      return this._plain + "ましょう";
    };

    return PoliteVerb;

  })(Word);

  PoliteVerbNegative = (function(superClass) {
    extend(PoliteVerbNegative, superClass);

    function PoliteVerbNegative(_plain) {
      this._plain = _plain;
    }

    PoliteVerbNegative.prototype.plain = function() {
      return this._plain + "ません";
    };

    PoliteVerbNegative.prototype.toString = function() {
      return this.plain();
    };

    PoliteVerbNegative.prototype.past = function() {
      return this._plain + "ませんでした";
    };

    return PoliteVerbNegative;

  })(PoliteVerb);

  RuVerb = (function(superClass) {
    extend(RuVerb, superClass);

    function RuVerb() {
      return RuVerb.__super__.constructor.apply(this, arguments);
    }

    RuVerb.prototype.type = function() {
      return "ru-verb";
    };

    RuVerb.prototype.stem = function() {
      return this._plain.replace(/る$/, "");
    };

    RuVerb.prototype.negative = function() {
      return new IAdjective(this.stem() + "ない");
    };

    RuVerb.prototype.past = function() {
      return this.stem() + "た";
    };

    RuVerb.prototype.potential = function() {
      return new RuVerb(this.stem() + "られる");
    };

    RuVerb.prototype.volitional = function() {
      return this.stem() + "よう";
    };

    return RuVerb;

  })(Verb);

  UVerb = (function(superClass) {
    extend(UVerb, superClass);

    function UVerb() {
      return UVerb.__super__.constructor.apply(this, arguments);
    }

    UVerb.prototype.type = function() {
      return "u-verb";
    };

    UVerb.prototype.stem = function() {
      return this._plain.replaceLast(uSounds, iSounds);
    };

    UVerb.prototype.negative = function() {
      var base;
      base = (function() {
        switch (this._plain) {
          case "ある":
            return "ない";
          default:
            return this._plain.replace(/う$/, "わ").replaceLast(uSounds, aSounds) + "ない";
        }
      }).call(this);
      return new IAdjective(base);
    };

    UVerb.prototype.past = function() {
      switch (this._plain) {
        case "行く":
          return "行った";
        default:
          return this._plain.replace(/う$/, "った").replace(/つ$/, "った").replace(/る$/, "った").replace(/む$/, "んだ").replace(/ぶ$/, "んだ").replace(/ぬ$/, "んだ").replace(/す$/, "した").replace(/く$/, "いた").replace(/ぐ$/, "いだ");
      }
    };

    UVerb.prototype.potential = function() {
      return new RuVerb(this._plain.replaceLast(uSounds, eSounds) + "る");
    };

    UVerb.prototype.volitional = function() {
      return this._plain.replaceLast(uSounds, oSounds) + "う";
    };

    return UVerb;

  })(Verb);

  Suru = (function(superClass) {
    extend(Suru, superClass);

    function Suru() {
      return Suru.__super__.constructor.apply(this, arguments);
    }

    Suru.prototype.type = function() {
      return "suru-verb";
    };

    Suru.prototype.stem = function() {
      return "し";
    };

    Suru.prototype.negative = function() {
      return new IAdjective("しない");
    };

    Suru.prototype.past = function() {
      return "した";
    };

    Suru.prototype.potential = function() {
      return new RuVerb("できる");
    };

    Suru.prototype.volitional = function() {
      return "しよう";
    };

    return Suru;

  })(Verb);

  Kuru = (function(superClass) {
    extend(Kuru, superClass);

    function Kuru() {
      return Kuru.__super__.constructor.apply(this, arguments);
    }

    Kuru.prototype.type = function() {
      return "kuru-verb";
    };

    Kuru.prototype.stem = function() {
      return "き";
    };

    Kuru.prototype.negative = function() {
      return new IAdjective("こない");
    };

    Kuru.prototype.past = function() {
      return "きた";
    };

    Kuru.prototype.potential = function() {
      return new RuVerb("こられる");
    };

    Kuru.prototype.volitional = function() {
      return "こよう";
    };

    return Kuru;

  })(Verb);

  Adjective = (function(superClass) {
    extend(Adjective, superClass);

    function Adjective() {
      return Adjective.__super__.constructor.apply(this, arguments);
    }

    Adjective.prototype.polite = function() {
      return new PoliteAdjective(this);
    };

    Adjective.prototype.toString = function() {
      return this.plain();
    };

    return Adjective;

  })(Word);

  PoliteAdjective = (function(superClass) {
    extend(PoliteAdjective, superClass);

    function PoliteAdjective(_plain) {
      this._plain = _plain;
    }

    PoliteAdjective.prototype.plain = function() {
      return this._plain + "です";
    };

    PoliteAdjective.prototype.toString = function() {
      return this.plain();
    };

    PoliteAdjective.prototype.negative = function() {
      return new PoliteAdjectiveNegative(this._plain.negative());
    };

    PoliteAdjective.prototype.past = function() {
      return this._plain.past() + "です";
    };

    return PoliteAdjective;

  })(Adjective);

  PoliteAdjectiveNegative = (function(superClass) {
    extend(PoliteAdjectiveNegative, superClass);

    function PoliteAdjectiveNegative(_plain) {
      this._plain = _plain;
    }

    PoliteAdjectiveNegative.prototype.plain = function() {
      return this._plain + "です";
    };

    PoliteAdjectiveNegative.prototype.past = function() {
      return this._plain.past() + "です";
    };

    return PoliteAdjectiveNegative;

  })(PoliteAdjective);

  PoliteNaAdjective = (function(superClass) {
    extend(PoliteNaAdjective, superClass);

    function PoliteNaAdjective() {
      return PoliteNaAdjective.__super__.constructor.apply(this, arguments);
    }

    PoliteNaAdjective.prototype.past = function() {
      return this._plain + "でした";
    };

    return PoliteNaAdjective;

  })(PoliteAdjective);

  IAdjective = (function(superClass) {
    extend(IAdjective, superClass);

    function IAdjective() {
      return IAdjective.__super__.constructor.apply(this, arguments);
    }

    IAdjective.prototype.type = function() {
      return "i-adjective";
    };

    IAdjective.prototype.adverb = function() {
      return this._plain.replace(/い$/, "く");
    };

    IAdjective.prototype.negative = function() {
      return new IAdjective(this._plain.replace(/い$/, "くない"));
    };

    IAdjective.prototype.past = function() {
      return this._plain.replace(/い$/, "かった");
    };

    IAdjective.prototype.te = function() {
      return this._plain.replace(/い$/, "くて");
    };

    IAdjective.prototype.conditional = function() {
      return this._plain.replace(/い$/, "ければ");
    };

    return IAdjective;

  })(Adjective);

  II = (function(superClass) {
    extend(II, superClass);

    function II() {
      return II.__super__.constructor.apply(this, arguments);
    }

    II.prototype.plain = function() {
      return "いい";
    };

    return II;

  })(IAdjective);

  NaAdjective = (function(superClass) {
    extend(NaAdjective, superClass);

    function NaAdjective() {
      return NaAdjective.__super__.constructor.apply(this, arguments);
    }

    NaAdjective.prototype.type = function() {
      return "na-adjective";
    };

    NaAdjective.prototype.adverb = function() {
      return this._plain + "に";
    };

    NaAdjective.prototype.negative = function() {
      return new IAdjective(this._plain + "じゃない");
    };

    NaAdjective.prototype.past = function() {
      return this._plain + "だった";
    };

    NaAdjective.prototype.te = function() {
      return this._plain + "で";
    };

    NaAdjective.prototype.conditional = function() {
      return this._plain + "であれば";
    };

    return NaAdjective;

  })(Adjective);

  verbs = [
    {
      plain: "見る",
      reading: "みる",
      meaning: "to see"
    }, {
      plain: "食べる",
      reading: "たべる",
      meaning: "to eat"
    }, {
      plain: "寝る",
      reading: "ねる",
      meaning: "to sleep"
    }, {
      plain: "起きる",
      reading: "おきる",
      meaning: "to wake up"
    }, {
      plain: "考える",
      reading: "かんがえる",
      meaning: "to think"
    }, {
      plain: "教える",
      reading: "おしえる",
      meaning: "to teach"
    }, {
      plain: "出る",
      reading: "でる",
      meaning: "to exit"
    }, {
      plain: "着る",
      reading: "きる",
      meaning: "to wear"
    }, {
      plain: "居る",
      reading: "いる",
      meaning: "to be (animate)"
    }, {
      plain: "在る",
      reading: "ある",
      meaning: "to be (inanimate)"
    }, {
      plain: "話す",
      reading: "はなす",
      meaning: "to talk"
    }, {
      plain: "聞く",
      reading: "きく",
      meaning: "to hear"
    }, {
      plain: "泳ぐ",
      reading: "およぐ",
      meaning: "to swim"
    }, {
      plain: "遊ぶ",
      reading: "あそぶ",
      meaning: "to play"
    }, {
      plain: "待つ",
      reading: "まつ",
      meaning: "to wait"
    }, {
      plain: "飲む",
      reading: "のむ",
      meaning: "to drink"
    }, {
      plain: "買う",
      reading: "かう",
      meaning: "to buy"
    }, {
      plain: "帰る",
      reading: "かえる",
      meaning: "to return"
    }, {
      plain: "死ぬ",
      reading: "しぬ",
      meaning: "to die"
    }, {
      plain: "為る",
      reading: "する",
      meaning: "to do"
    }, {
      plain: "来る",
      reading: "くる",
      meaning: "to come"
    }
  ];

  adjectives = [
    {
      plain: "良い",
      reading: "いい",
      meaning: "good"
    }, {
      plain: "奇麗",
      reading: "きれい",
      meaning: "pretty"
    }, {
      plain: "静か",
      reading: "しずか",
      meaning: "quiet"
    }, {
      plain: "親切",
      reading: "しんせつ",
      meaning: "kind"
    }, {
      plain: "好き",
      reading: "すき",
      meaning: "like"
    }, {
      plain: "嫌い",
      reading: "きらい",
      meaning: "hate"
    }, {
      plain: "美味しい",
      reading: "おいしい",
      meaning: "tasty"
    }, {
      plain: "高い",
      reading: "たかい",
      meaning: "tall"
    }
  ];

  window.classify = function(plain, reading, meaning) {
    var ref;
    switch (reading) {
      case "する":
        return new Suru(plain, reading, meaning);
      case "くる":
        return new Kuru(plain, reading, meaning);
      case "いい":
        return new II(plain, reading, meaning);
      default:
        switch (plain.slice(-1)) {
          case "う":
          case "つ":
          case "む":
          case "ぶ":
          case "ぬ":
          case "す":
          case "く":
          case "ぐ":
            return new UVerb(plain, reading, meaning);
          case "る":
            switch (plain) {
              case "要る":
              case "帰る":
              case "切る":
              case "喋る":
              case "知る":
              case "入る":
              case "走る":
              case "減る":
              case "焦る":
              case "限る":
              case "蹴る":
              case "滑る":
              case "握る":
              case "練る":
              case "参る":
              case "交じる":
              case "混じる":
              case "嘲る":
              case "覆る":
              case "遮る":
              case "罵る":
              case "捻る":
              case "翻る":
              case "滅入る":
              case "蘇る":
                return new UVerb(plain, reading, meaning);
              default:
                if (ref = reading.slice(-2, -1), indexOf.call(eSounds.concat(iSounds), ref) >= 0) {
                  return new RuVerb(plain, reading, meaning);
                } else {
                  return new UVerb(plain, reading, meaning);
                }
            }
            break;
          case "い":
            switch (plain) {
              case "嫌い":
              case "奇麗":
              case "綺麗":
              case "きれい":
                return new NaAdjective(plain, reading, meaning);
              default:
                return new IAdjective(plain, reading, meaning);
            }
            break;
          default:
            return new NaAdjective(plain, reading, meaning);
        }
    }
  };

  window.words = (function() {
    var j, len, ref, results;
    ref = verbs.concat(adjectives);
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      w = ref[j];
      results.push(classify(w.plain, w.reading, w.meaning));
    }
    return results;
  })();

  window.getByPlain = function(plain) {
    var j, len, ref;
    ref = window.words;
    for (j = 0, len = ref.length; j < len; j++) {
      w = ref[j];
      if (w.plain() === plain) {
        return w;
      }
    }
  };

}).call(this);



// Generated by CoffeeScript 1.10.0
(function() {
  var makeKey;

  makeKey = function(name) {
    return 'mononofu_' + name;
  };

  window.globalSet = function(name, value) {
    if (typeof py !== "undefined") {
      return py[makeKey(name)] = value.toString();
    } else if (typeof sessionStorage !== "undefined") {
      return sessionStorage.setItem(makeKey(name), value.toString());
    } else {
      return window[makeKey(name)] = value.toString();
    }
  };

  window.globalGet = function(name) {
    if (typeof py !== "undefined") {
      return py[makeKey(name)];
    } else if (typeof sessionStorage !== "undefined") {
      return sessionStorage.getItem(makeKey(name));
    } else {
      return window[makeKey(name)];
    }
  };

}).call(this);



// Generated by CoffeeScript 1.10.0
(function() {
  var candidates, elem, error, error1, k, l, len, len1, ref, ref1, shuffle, type, w, word;

  shuffle = function(xs) {
    var i, j, k, ref, ref1;
    for (i = k = ref = xs.length - 1; ref <= 0 ? k < 0 : k > 0; i = ref <= 0 ? ++k : --k) {
      j = Math.floor(Math.random() * xs.length);
      ref1 = [xs[j], xs[i]], xs[i] = ref1[0], xs[j] = ref1[1];
    }
    return xs;
  };

  if (document.getElementById('answer') === null) {
    candidates = window.words;
    type = document.getElementById('word-type');
    if (type !== null && type.innerHTML !== '') {
      candidates = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = candidates.length; k < len; k++) {
          w = candidates[k];
          if (w.type().indexOf(type.innerHTML) === 0) {
            results.push(w);
          }
        }
        return results;
      })();
    }
    ref = shuffle(candidates);
    for (k = 0, len = ref.length; k < len; k++) {
      word = ref[k];
      try {
        ref1 = document.getElementsByClassName('required-conjugation');
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          elem = ref1[l];
          word.conjugate(elem.innerHTML);
        }
        globalSet('word', word);
        break;
      } catch (error1) {
        error = error1;
        document.getElementById('error').innerHTML = error;
      }
    }
  }

  elem = document.getElementById('replace-front');

  elem.innerHTML = getByPlain(globalGet('word')).conjugate(elem.innerHTML);

  document.getElementById('error').innerHTML = '';

}).call(this);

</script>